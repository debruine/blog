---
title: LMER vs ANOVA
author: ~
date: "2019-01-10"
slug: lmer-vs-anova
categories: ["rstats"]
tags: ["R", "simulation", "lmer", "lme4", "anova"]
draft: true
---

This tutorial will walk you through generating a dataset using a function modified from [Simulating Random Slopes][simulating-random-slopes] and comparing the output of a mixed effects model with the output of ANOVAs run on the data aggregated by subjects or by stimuli. We'll use the `afex` package to run our ANOVAs.

```{r setup, message=FALSE}
library(tidyverse)
library(lmerTest)
library(afex)
library(faux)
options("scipen"=10, "digits"=4)
set.seed(8675309) # Jenny, I've got your number
```

## Functions

### Generate Data

This function is just the dataset generating code from the function in [Simulating Random Slopes][simulating-random-slopes]. It returns a data frame with the specified properties. The defaults of this function are set to default to null effects, with all intecept/slope correlations set to Â±0.2 and all intercept and slope SDs set to 50.

```{r sim-dat}
sim_dat  <- function( sub_n = 100,
                      sub_sd = 50,
                      sub_version_sd = 50, 
                      sub_i_version_cor = -0.2,
                      stim_n = 50,
                      stim_sd = 50,
                      stim_version_sd = 50,
                      stim_cond_sd = 50,
                      stim_cond_version_sd = 50,
                      stim_i_cor = -0.2,
                      stim_s_cor = +0.2,
                      grand_i = 400,
                      hard_congr = 0,
                      hard_incon = 0,
                      easy_congr = 0,
                      easy_incon = 0,
                      error_sd = 50) {
  sub <- rnorm_multi(
    n = sub_n, 
    vars = 2, 
    cors = sub_i_version_cor,
    mu = 0, # means of random intercepts and slopes are always 0
    sd = c(sub_sd, sub_version_sd),
    varnames = c("sub_i", "sub_version_slope")
  ) %>%
    mutate(
      sub_id = 1:sub_n,
      sub_cond = rep(c("easy","hard"), each = sub_n/2) # between-subjects factor
    )
  
  stim_cors <- c(stim_i_cor, stim_i_cor, stim_i_cor,
                             stim_s_cor, stim_s_cor,
                                         stim_s_cor)
  stim <- rnorm_multi(
    n = stim_n, 
    vars = 4, 
    cors = stim_cors, 
    mu = 0, # means of random intercepts and slopes are always 0
    sd = c(stim_sd, stim_version_sd, stim_cond_sd, stim_cond_version_sd),
    varnames = c("stim_i", "stim_version_slope", "stim_cond_slope", "stim_cond_version_slope")
  ) %>%
    mutate(
      stim_id = 1:stim_n
    )
  
  # mean difference between easy and hard conditions
  sub_cond_eff     <- (easy_congr + easy_incon)/2 -
                      (hard_congr + hard_incon)/2
  # mean difference between incongruent and congruent versions
  stim_version_eff <- (hard_incon + easy_incon)/2 - 
                      (hard_congr + easy_congr)/2  
  # interaction between version and condition
  cond_version_ixn <- (easy_incon - easy_congr) -
                      (hard_incon - hard_congr) 
  
  trials <- expand.grid(
    sub_id = sub$sub_id, # get subject IDs from the sub data table
    stim_id = stim$stim_id, # get stimulus IDs from the stim data table
    stim_version = c("congruent", "incongruent") # all subjects see both congruent and incongruent versions of all stimuli
  ) %>%
    left_join(sub, by = "sub_id") %>% # includes the intercept, slope, and conditin for each subject
    left_join(stim, by = "stim_id")   # includes the intercept and slopes for each stimulus
  
  dat <- trials %>%
    mutate(
      # effect-code subject condition and stimulus version
      sub_cond.e = recode(sub_cond, "hard" = -0.5, "easy" = +0.5),
      stim_version.e = recode(stim_version, "congruent" = -0.5, "incongruent" = +0.5),
      # calculate trial-specific effects by adding overall effects and slopes
      version_eff = stim_version_eff + stim_version_slope + sub_version_slope,
      cond_eff = sub_cond_eff + stim_cond_slope,
      cond_version_eff = cond_version_ixn + stim_cond_version_slope,
      # calculate error term (normally distributed residual with SD set above)
      err = rnorm(nrow(.), 0, error_sd),
      # calculate DV from intercepts, effects, and error
      dv = grand_i + sub_i + stim_i + err +
           (sub_cond.e * cond_eff) + 
           (stim_version.e * version_eff) + 
           (sub_cond.e * stim_version.e * cond_version_eff)
    )
  return(dat)
}
  
```

### Linear Mixed Effects Regression

The `sim_lmer` function takes a dataset generated by `sim_dat` and returns the summary output of a maximally specified linear mixed effects regression.

```{r sim-lmer}
sim_lmer <- function(dat) {
  mod <- lmer(dv ~ sub_cond.e * stim_version.e +
                (1 + stim_version.e | sub_id) + 
                (1 + stim_version.e*sub_cond.e | stim_id),
              data = dat)
  
  mod.sum <- summary(mod)
  
  return(mod.sum)
}
```

### By-Subject ANOVA

The `sim_sub_anova` function takes a dataset generated by `sim_dat`, groups the data by subject ID and stimulus version, averages the DV to produce one score for congruent and one score for incongruent stimuli for each subject, and returns the summary output of an ANOVA with the between-subjects factor of `condition` and the within-subjects factor of `version`.

```{r sim-sub-anova}
sim_sub_anova <- function(dat) {
  dat_sub <- dat %>%
    group_by(sub_id, sub_cond, sub_cond.e, stim_version, stim_version.e) %>%
    summarise(dv = mean(dv))
  
  mod <- afex::aov_4(dv ~ sub_cond.e + (stim_version.e| sub_id),
                     factorize = FALSE, check_contrasts = FALSE,
                     data = dat_sub)
  
  mod.sum <- anova(mod)
  
  return(mod.sum)
}
```

### By-Stimulus ANOVA

The `sim_stim_anova` function takes a dataset generated by `sim_dat`, groups the data by stimulus ID and subject condition, averages the DV to produce four scores for each stimulus (hard congruent, easy congruent, hard incongruent, and easy incongruent), and returns the summary output of an ANOVA with the within-stimulus factor of `condition` and the within-stimulus factor of `version`.

```{r sim-stim-anova}
sim_stim_anova <- function(dat) {
  dat_stim <- dat %>%
    group_by(stim_id, sub_cond, sub_cond.e, stim_version, stim_version.e) %>%
    summarise(dv = mean(dv))
  
  mod <- afex::aov_4(dv ~ (sub_cond.e * stim_version.e | stim_id),
                     factorize = FALSE, check_contrasts = FALSE,
                     data = dat_stim)
  
  mod.sum <- anova(mod)
  
  return(mod.sum)
}
```

## Example

In this example, 50 subjects view 20 stimuli. There is a main effect of version (incongruent > congruent), no effect of condition (easy == hard), and an interaction between sondition and version (the effect of version is larger for the easy condition than the hard condition). I've increased `error_sd` to 100.

```{r}
dat <- sim_dat(sub_n = 50,
               stim_n = 20,
               hard_congr = -10,
               hard_incon = +10,
               easy_congr = -20,
               easy_incon = +20,
               error_sd = 100)
```


```{r}
sim_lmer(dat)
```


```{r}
sim_sub_anova(dat)
```


```{r}
sim_stim_anova(dat)
```



```{r sim-power}
sim_power <- function(rep = 0) {
  dat <- sim_dat(
    sub_n = 50,
    stim_n = 20,
    hard_congr = -10,
    hard_incon = +10,
    easy_congr = -20,
    easy_incon = +20,
    error_sd = 100
  )
  
  mod.lmer <- sim_lmer(dat)
  mod.sub <- sim_sub_anova(dat)
  mod.stim <- sim_stim_anova(dat)
  

  table.lmer <- mod.lmer$coefficients %>%
    as_tibble(rownames = "effect") %>%
    select(effect, es = Estimate, p = 6) %>%
    mutate(analysis = "lmer")
  
  table.sub <- mod.sub %>%
    as_tibble(rownames = "effect") %>%
    select(effect, es = ges, p = 7) %>%
    mutate(analysis = "anova_sub")
  
  table.stim <- mod.stim %>%
    as_tibble(rownames = "effect") %>%
    select(effect, es = ges, p = 7) %>%
    mutate(analysis = "anova_stim")

  bind_rows(table.lmer, table.sub, table.stim) %>%
    mutate(rep = rep)
}
```

Now we run the function above 100 times. This will take a few minutes; be patient.

```{r}
power <- purrr::map_df(1:100, sim_power)
```

Here is a plot of the distribution of p-values for the three types of analysis.

```{r plot-power-p, fig.width = 10, fig.height = 8}
power %>%
  filter(effect != "(Intercept)") %>%
  ggplot(aes(p, fill = analysis, color = analysis)) +
  geom_density(alpha = 0.1) +
  facet_grid(effect~., scales = "free_y")
```

```{r plot-es-anova, fig.width = 10, fig.height = 8}
power %>%
  filter(effect != "(Intercept)", analysis != "lmer") %>%
  group_by(analysis, effect) %>%
  mutate(mean_es = mean(es)) %>%
  ungroup() %>%
  ggplot(aes(es, fill = analysis, color = analysis)) +
  geom_density(alpha = 0.1) +
  geom_vline(aes(xintercept = mean_es, color = analysis)) +
  facet_grid(effect~., scales = "free_y")
```

```{r plot-es-lmer, fig.width = 10, fig.height = 8}
power %>%
  filter(effect != "(Intercept)", analysis == "lmer") %>%
  group_by(analysis, effect) %>%
  mutate(mean_es = mean(es)) %>%
  ungroup() %>%
  ggplot(aes(es, fill = analysis, color = analysis)) +
  geom_density(alpha = 0.1) +
  geom_vline(aes(xintercept = mean_es, color = analysis)) +
  facet_grid(effect~., scales = "free_y")
```

